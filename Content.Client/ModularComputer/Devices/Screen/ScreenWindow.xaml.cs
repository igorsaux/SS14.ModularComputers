//-----------------------------------------------------------------------------
// Copyright 2024 Igor Spichkin
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-----------------------------------------------------------------------------

using System.IO;
using Content.Client.Stylesheets;
using Content.Shared.ModularComputer.Devices.Screen;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.Input;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Utility;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;

namespace Content.Client.ModularComputer.Devices.Screen;

[GenerateTypedNameReferences]
public sealed partial class ScreenWindow : BaseWindow
{
    [Dependency]
    private readonly IClyde _clyde = default!;

    [Dependency]
    private readonly IResourceCache _resourceCache = default!;

    private int _height;
    private int _width;
    private OwnedTexture? _texture;
    
    public Action<KeyEventArgs, KeyEventType>? KeyEvent;
    public Action<GUIMouseEventArgs>? MouseEvent;

    public ScreenWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        CloseButton.OnPressed += _ => Close();
        Screen.KeyEvent += (args, type) => KeyEvent?.Invoke(args, type);
        Screen.MouseEvent += OnMouseEvent;

        Screen.SetShader("Crt", shader =>
        {
            shader.SetParameter("roll", false);
            shader.SetParameter("roll_size", 0.5f);
            shader.SetParameter("discolor", true);
            shader.SetParameter("saturation", 0.15f);
            shader.SetParameter("noise_opacity", 0.4f);
            shader.SetParameter("static_noise_intensity", 0.04f);
            shader.SetParameter("warp_amount", 0.05f);
            shader.SetParameter("vignette_opacity", 0.6f);
            shader.SetParameter("vignette_intensity", 0.6f);
            shader.SetParameter("aberration", 0.01f);
            shader.SetParameter("pixelate", false);
            shader.SetParameter("scanlines_opacity", 0.2f);
        });

        ScreenLabel.FontOverride = _resourceCache.GolosUIStack("Black", 12);
    }

    private void OnMouseEvent(GUIMouseEventArgs args)
    {
        MouseEvent?.Invoke(args);
    }

    protected override DragMode GetDragModeFor(Vector2 relativeMousePos)
    {
        return DragMode.Move;
    }

    public void UpdateState(ScreenBoundUserInterfaceState state)
    {
        if (_width != state.Width || _height != state.Height)
        {
            _texture?.Dispose();
            _texture = null;
        }

        _width = state.Width;
        _height = state.Height;

        Screen.SetWidth = _width * UIScale;
        Screen.SetHeight = _height * UIScale;

        Background.ModulateSelfOverride = state.BorderColor;
        ScreenLabel.FontColorOverride = state.LabelColor;
        ScreenLabel.Text = state.Label;
        
        if (_texture is null)
        {
            _texture = _clyde.CreateBlankTexture<Rgba32>(new Vector2i(_width, _height));
            Screen.Texture = _texture;
        }
        
        if (state.Framebuffer is not { } framebuffer)
        {
            var image = new Image<Rgba32>(_width, _height, new Rgba32(0, 0, 0));
            _texture.SetSubImage(Vector2i.Zero, image);
        }
        else
        {
            using var ctx = new ZStdDecompressStream(new MemoryStream(framebuffer.Data));
            var bitmap = new byte[framebuffer.UncompressedSize];

            ctx.ReadToEnd(bitmap);
            
            var pixels = new Rgba32[bitmap.Length / 4];
        
            for (var i = 0; i < bitmap.Length; i += 4)
            {
                pixels[i / 4] = new Rgba32(bitmap[i], bitmap[i + 1], bitmap[i + 2], bitmap[i + 3]);
            }
            
            _texture.SetSubImage<Rgba32>(Vector2i.Zero, new Vector2i(state.Width, state.Height), pixels.AsSpan());
        }
    }

    public override void Close()
    {
        base.Close();

        _texture?.Dispose();
        _texture = null;
    }
}
